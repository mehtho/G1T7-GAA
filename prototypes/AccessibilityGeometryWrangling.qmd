TODO (In order of priority):

-   MPSZ 2019

    -   Make 3 Hexagon Layers (250, 400, 750m) OK

    -   Calculate Distance Matrices OK

        -   Have the raw Euclidean distance matrix OK

-   Market & Food Centers

-   Supermarkets

```{r}
pacman::p_load(tidyverse, tmap, sf, dplyr, smoothr)
```

Reference: Matt's Takehome Exercise 1

```{r}
mpsz <- st_read("../data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml") %>% 
  mutate(Match=str_match_all(Description,"<td>(.*?)</td>")) %>% 
  mutate(Match=map(Match, ~ .[,2])) %>% 
  mutate(Match=map(Match,setNames,c("SUBZONE_NO","SUBZONE_N","SUBZONE_C", "CA_IND", "PLN_AREA_N", "PLN_AREA_C", "REGION_N", "REGION_C", "INC_CRC", "FMEL_UPD_D"))) %>% 
  unnest_wider(Match) %>%
  st_as_sf() %>% dplyr::select('Name', 'geometry', 'SUBZONE_NO', 'SUBZONE_N', 'PLN_AREA_N', 'PLN_AREA_C', 'REGION_N', 'REGION_C') %>% 
  st_make_valid() %>%
  st_zm() %>%
  st_transform(crs = 3414)
```

```{r}
write_rds(mpsz, '../data/rds/mpsz.rds')
```

```{r}
pops <- read_rds('../data/rds/pop2020.rds')

pop2020_pa <- read_rds('../data/rds/pop2020.rds') %>%
  mutate(Total = as.numeric(Total)) %>%
  group_by(Planning_Area) %>%
  summarise(Total = sum(Total), .groups = "drop")

pop2020_sz <- read_rds('../data/rds/pop2020.rds') %>%
  mutate(Total = as.numeric(Total)) %>%
  group_by(Subzone) %>%
  summarise(Total = sum(Total), .groups = "drop")

mpsz_pa <- mpsz %>%
  group_by(PLN_AREA_N) %>%
  summarise(geometry = st_union(geometry), .groups = "drop") %>% 
  merge(pop2020_pa, by.x="PLN_AREA_N", by.y="Planning_Area") %>% 
  mutate(Total = as.numeric(Total),
           area = st_area(geometry), 
           pop_dens = Total / area)

mpsz_sz <- mpsz %>%
  group_by(SUBZONE_N) %>%
  summarise(geometry = st_union(geometry), .groups = "drop") %>% 
  merge(pop2020_sz, by.x="SUBZONE_N", by.y="Subzone") %>% 
  mutate(Total = as.numeric(Total),
           area = st_area(geometry), 
           pop_dens = Total / area)

mpsz_pa$area <- st_area(mpsz_pa$geometry)
mpsz_pa$pop_dens <- mpsz_pa$Total / mpsz_pa$area

mpsz_sz$area <- st_area(mpsz_sz$geometry)
mpsz_sz$pop_dens <- mpsz_sz$Total / mpsz_sz$area

write_rds(mpsz_pa, '../data/rds/mpsz_pa.rds')
write_rds(mpsz_sz, '../data/rds/mpsz_sz.rds')
```

Reference: Matt's Takehome Exercise 1

```{r}
mainland_sg <- st_union(mpsz_pa) %>%
    st_cast("POLYGON")

mainland_sg <- mainland_sg[c(15)]
mainland_sg <- fill_holes(mainland_sg, units::set_units(1, "km^2"))
mainland_sg <- st_as_sf(mainland_sg)

write_rds(mainland_sg, '../data/rds/mainland_sg.rds')
```

References: https://r-spatial.github.io/sf/reference/st_make_grid.html https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/paste

```{r}
add_weights <- function(grids, pop) {
  joined <- st_join(grids, pop, join = st_intersects)  %>%
    mutate(intersect_area = st_area(x),
           demand = intersect_area * pop_dens) %>%
    st_drop_geometry()
  
  grids <- grids %>%
    left_join(joined %>%
                group_by(ID) %>%
                summarise(total_demand = sum(demand)),
              by = "ID") %>%
    mutate(demand = ifelse(is.na(total_demand), 0, total_demand)) %>%
    select(-total_demand)
}
```

```{r}
sg_2_grid <- function(sg, g_size, is_square, name, pop) {
  grids <- st_make_grid(sg, cellsize = g_size, square = is_square) %>%
  st_intersection(mainland_sg) %>%
  st_as_sf() %>%
    mutate(demand = 0, ID = row_number())
  
  grids_w_demand <- add_weights(grids, pop) %>%
  rename(geometry = x)
  
  # Need to modify with weights
  write_rds(grids_w_demand, paste(name, '.rds', sep = ""))
  
  return(grids_w_demand)
}
```

References: https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/dist https://www.rdocumentation.org/packages/geosphere/versions/1.5-18/topics/centroid

```{r}
grids_and_dist_matrices <- function(sg, pop, g_size, is_square, subz) {
  name <- paste('../data/rds/grid_', g_size, ifelse(is_square, "_square", "_hexagon"), ifelse(subz, "_sz", "_pa"), sep = "")
  
  
  grid <- sg_2_grid(sg, g_size, is_square, name, pop)
  return(grid)
}
```

```{r}
for(di in c(250, 500, 750, 1000)) {
  grids_and_dist_matrices(mainland_sg, mpsz_sz, di, FALSE, TRUE)
  grids_and_dist_matrices(mainland_sg, mpsz_sz, di, TRUE, TRUE)
  grids_and_dist_matrices(mainland_sg, mpsz_pa, di, FALSE, FALSE)
  grids_and_dist_matrices(mainland_sg, mpsz_pa, di, TRUE, FALSE)
}
```

```{r}
print(subset(mpsz_pa, Total == 0))
```

```{r}
set1 <- unique(mpsz_sz$SUBZONE_N)
set2 <- unique(pop2020_sz$Subzone)

# Find elements that are not shared
not_shared <- setdiff(set1, set2)
not_shared <- c(not_shared, setdiff(set2, set1)) # Include elements from set2 not in set1

# Print the elements that are not shared
print(not_shared)
```
